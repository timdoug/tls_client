#!/usr/bin/env python3
"""Fetch Chrome's CT log list and emit ct_log_table.inc for tls_client.

Fetches log_list.json (Chrome's authoritative list of usable, qualified,
readonly, and retired logs, including Sunlight/tiled logs). Extracts all
ECDSA P-256 logs, computes log_id = SHA-256(SPKI DER), and extracts the
65-byte uncompressed EC point from the DER SubjectPublicKeyInfo.
"""

import base64, hashlib, json, sys, urllib.request

LOG_LIST_URL = "https://www.gstatic.com/ct/log_list/v3/log_list.json"

# DER OID for id-ecPublicKey (1.2.840.10045.2.1)
EC_PUBKEY_OID = bytes([0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x02, 0x01])
# DER OID for prime256v1 / secp256r1 (1.2.840.10045.3.1.7)
P256_OID = bytes([0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07])


def der_read_tl(data, offset):
    """Read a DER tag and length, return (tag, length, value_offset)."""
    if offset >= len(data):
        return None, 0, offset
    tag = data[offset]
    offset += 1
    if offset >= len(data):
        return None, 0, offset
    b = data[offset]
    offset += 1
    if b < 0x80:
        return tag, b, offset
    num_bytes = b & 0x7F
    if num_bytes == 0 or offset + num_bytes > len(data):
        return None, 0, offset
    length = 0
    for i in range(num_bytes):
        length = (length << 8) | data[offset + i]
    offset += num_bytes
    return tag, length, offset


def extract_p256_point(spki_der):
    """Extract 65-byte uncompressed P-256 point from DER SubjectPublicKeyInfo.

    Returns the point bytes or None if not an EC P-256 key.
    """
    off = 0
    # Outer SEQUENCE
    tag, seq_len, off = der_read_tl(spki_der, off)
    if tag != 0x30:
        return None

    # AlgorithmIdentifier SEQUENCE
    tag, alg_len, alg_off = der_read_tl(spki_der, off)
    if tag != 0x30:
        return None
    alg_end = alg_off + alg_len

    # Algorithm OID
    tag, oid_len, oid_off = der_read_tl(spki_der, alg_off)
    if tag != 0x06:
        return None
    oid_bytes = spki_der[oid_off:oid_off + oid_len]
    if oid_bytes != EC_PUBKEY_OID:
        return None  # Not an EC key

    # Named curve OID parameter
    tag, curve_len, curve_off = der_read_tl(spki_der, oid_off + oid_len)
    if tag != 0x06:
        return None
    curve_bytes = spki_der[curve_off:curve_off + curve_len]
    if curve_bytes != P256_OID:
        return None  # Not P-256

    # BIT STRING containing the public key
    tag, bs_len, bs_off = der_read_tl(spki_der, alg_end)
    if tag != 0x03 or bs_len < 2:
        return None

    # First byte of BIT STRING is unused-bits count (should be 0)
    if spki_der[bs_off] != 0x00:
        return None

    point = spki_der[bs_off + 1:bs_off + bs_len]
    if len(point) != 65 or point[0] != 0x04:
        return None  # Not uncompressed point

    return point


def format_bytes(data, indent="    "):
    """Format bytes as C hex initializer."""
    parts = []
    for i in range(0, len(data), 12):
        chunk = data[i:i + 12]
        hex_vals = ",".join(f"0x{b:02x}" for b in chunk)
        parts.append(f"{indent}{hex_vals}")
    return ",\n".join(parts)


def main():
    req = urllib.request.Request(LOG_LIST_URL)
    with urllib.request.urlopen(req) as resp:
        log_list = json.loads(resp.read().decode())

    entries = []
    seen_ids = set()
    skipped = 0
    operator_names = []  # ordered list of distinct operator names
    operator_id_map = {} # operator name -> uint8_t ID

    for operator in log_list.get("operators", []):
        op_name = operator.get("name", "unknown")
        # Process both regular logs and tiled/Sunlight logs
        all_logs = operator.get("logs", []) + operator.get("tiled_logs", [])
        for log in all_logs:
            key_b64 = log.get("key")
            if not key_b64:
                continue
            # Skip bogus placeholder logs (shims for libraries that can't
            # handle operators with an empty "logs" array)
            if "bogus" in log.get("url", "") or "bogus" in log.get("description", "").lower():
                continue
            spki_der = base64.b64decode(key_b64)
            log_id = hashlib.sha256(spki_der).digest()
            if log_id in seen_ids:
                continue
            point = extract_p256_point(spki_der)
            if point is None:
                skipped += 1
                continue
            if op_name not in operator_id_map:
                operator_id_map[op_name] = len(operator_names)
                operator_names.append(op_name)
            description = log.get("description", "unknown")
            entries.append((log_id, point, description, operator_id_map[op_name]))
            seen_ids.add(log_id)

    if not entries:
        print("Error: no P-256 CT logs found", file=sys.stderr)
        sys.exit(1)

    print(f"// ct_log_table.inc â€” generated by gen_ct_logs.py")
    print(f"// {len(entries)} ECDSA P-256 CT logs ({skipped} non-P256 skipped)")
    print(f"// Source: {LOG_LIST_URL}")
    print()
    print("// Operator ID mapping:")
    for oid, name in enumerate(operator_names):
        print(f"//   {oid} = {name}")
    print()
    print(f"#define CT_LOG_COUNT {len(entries)}")
    print()
    print("typedef struct { uint8_t log_id[32]; uint8_t pubkey[65]; uint8_t operator_id; } ct_log_entry;")
    print()
    print(f"static const ct_log_entry ct_logs[CT_LOG_COUNT] = {{")

    for i, (log_id, point, desc, op_id) in enumerate(entries):
        comma = "," if i < len(entries) - 1 else ""
        print(f"    /* {desc} */")
        print(f"    {{{{{format_bytes(log_id, '').strip()}}},")
        print(f"     {{{format_bytes(point, '').strip()}}},{op_id}}}{comma}")

    print("};")

    print(f"// Extracted {len(entries)} logs from {len(operator_names)} operators", file=sys.stderr)


if __name__ == "__main__":
    main()
